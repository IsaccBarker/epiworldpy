#include "database.hpp"
#include "interface.hpp"
#include "models/model.hpp"
#include "models/seirconn.hpp"
#include <pybind11/numpy.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h> /* silently fails when removed. */

namespace py = pybind11;
using namespace epiworld;

#define STRINGIFY(x) #x
#define MACRO_STRINGIFY(x) STRINGIFY(x)

PYBIND11_MODULE(_core, m) {
	m.doc() = R"pbdoc(
        Epiworld Python Wrapper
        -----------------------

        .. currentmodule:: epiworldpy

        .. autosummary::
           :toctree: _generate

           ModelSEIR
    )pbdoc";

	/* Export everything we know. For some reason, we have to create the classes
	 * here, instead of just passing in the module to the function and having it
	 * do it for us; we get a duplicate symbol error at Python import-time.
	 *
	 * TODO: Try using `py::model_` instead of `py::model`? */
	auto model = py::class_<Model<int>, std::shared_ptr<Model<int>>>(
		m, "Model", "A generic model of some kind; a parent class.");
	auto database = py::class_<DataBase<int>, std::shared_ptr<DataBase<int>>>(
		m, "DataBase", "A container for data generated by a model run.");
	auto seirconn = py::class_<epimodels::ModelSEIRCONN<int>,
							   std::shared_ptr<epimodels::ModelSEIRCONN<int>>>(
		m, "ModelSEIRCONN",
		"A model with four compartments: susceptible, exposed, infectious, and "
		"recovered.");

	epiworldpy::export_model(model);
	epiworldpy::export_database(database);
	epiworldpy::export_seirconn(seirconn);
	epiworldpy::export_sierconn_constructor(m);

#ifdef VERSION_INFO
	/* Give the real version. */
	m.attr("__version__") = MACRO_STRINGIFY(VERSION_INFO);
#else
	/* Also give the real version, but prefix with 'dev'. */
	m.attr("__version__") = "dev-" MACRO_STRINGIFY(VERSION_INFO);
#endif
}
